{"ast":null,"code":"\"use strict\"; // These use the global symbol registry so that multiple copies of this\n// library can work together in case they are not deduped.\n\nvar _regeneratorRuntime = require(\"C:/Users/lenovo/letterBox/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"C:/Users/lenovo/letterBox/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar GENSYNC_START = Symbol.for(\"gensync:v1:start\");\nvar GENSYNC_SUSPEND = Symbol.for(\"gensync:v1:suspend\");\nvar GENSYNC_EXPECTED_START = \"GENSYNC_EXPECTED_START\";\nvar GENSYNC_EXPECTED_SUSPEND = \"GENSYNC_EXPECTED_SUSPEND\";\nvar GENSYNC_OPTIONS_ERROR = \"GENSYNC_OPTIONS_ERROR\";\nvar GENSYNC_RACE_NONEMPTY = \"GENSYNC_RACE_NONEMPTY\";\nvar GENSYNC_ERRBACK_NO_CALLBACK = \"GENSYNC_ERRBACK_NO_CALLBACK\";\nmodule.exports = Object.assign(function gensync(optsOrFn) {\n  var genFn = optsOrFn;\n\n  if (typeof optsOrFn !== \"function\") {\n    genFn = newGenerator(optsOrFn);\n  } else {\n    genFn = wrapGenerator(optsOrFn);\n  }\n\n  return Object.assign(genFn, makeFunctionAPI(genFn));\n}, {\n  all: buildOperation({\n    name: \"all\",\n    arity: 1,\n    sync: function sync(args) {\n      var items = Array.from(args[0]);\n      return items.map(function (item) {\n        return evaluateSync(item);\n      });\n    },\n    async: function async(args, resolve, reject) {\n      var items = Array.from(args[0]);\n\n      if (items.length === 0) {\n        Promise.resolve().then(function () {\n          return resolve([]);\n        });\n        return;\n      }\n\n      var count = 0;\n      var results = items.map(function () {\n        return undefined;\n      });\n      items.forEach(function (item, i) {\n        evaluateAsync(item, function (val) {\n          results[i] = val;\n          count += 1;\n          if (count === results.length) resolve(results);\n        }, reject);\n      });\n    }\n  }),\n  race: buildOperation({\n    name: \"race\",\n    arity: 1,\n    sync: function sync(args) {\n      var items = Array.from(args[0]);\n\n      if (items.length === 0) {\n        throw makeError(\"Must race at least 1 item\", GENSYNC_RACE_NONEMPTY);\n      }\n\n      return evaluateSync(items[0]);\n    },\n    async: function async(args, resolve, reject) {\n      var items = Array.from(args[0]);\n\n      if (items.length === 0) {\n        throw makeError(\"Must race at least 1 item\", GENSYNC_RACE_NONEMPTY);\n      }\n\n      for (var _i = 0, _items = items; _i < _items.length; _i++) {\n        var item = _items[_i];\n        evaluateAsync(item, resolve, reject);\n      }\n    }\n  })\n});\n/**\n * Given a generator function, return the standard API object that executes\n * the generator and calls the callbacks.\n */\n\nfunction makeFunctionAPI(genFn) {\n  var fns = {\n    sync: function sync() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return evaluateSync(genFn.apply(this, args));\n    },\n    async: function async() {\n      var _this = this;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return new Promise(function (resolve, reject) {\n        evaluateAsync(genFn.apply(_this, args), resolve, reject);\n      });\n    },\n    errback: function errback() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var cb = args.pop();\n\n      if (typeof cb !== \"function\") {\n        throw makeError(\"Asynchronous function called without callback\", GENSYNC_ERRBACK_NO_CALLBACK);\n      }\n\n      var gen;\n\n      try {\n        gen = genFn.apply(this, args);\n      } catch (err) {\n        cb(err);\n        return;\n      }\n\n      evaluateAsync(gen, function (val) {\n        return cb(undefined, val);\n      }, function (err) {\n        return cb(err);\n      });\n    }\n  };\n  return fns;\n}\n\nfunction assertTypeof(type, name, value, allowUndefined) {\n  if (typeof value === type || allowUndefined && typeof value === \"undefined\") {\n    return;\n  }\n\n  var msg;\n\n  if (allowUndefined) {\n    msg = \"Expected opts.\".concat(name, \" to be either a \").concat(type, \", or undefined.\");\n  } else {\n    msg = \"Expected opts.\".concat(name, \" to be a \").concat(type, \".\");\n  }\n\n  throw makeError(msg, GENSYNC_OPTIONS_ERROR);\n}\n\nfunction makeError(msg, code) {\n  return Object.assign(new Error(msg), {\n    code: code\n  });\n}\n/**\n * Given an options object, return a new generator that dispatches the\n * correct handler based on sync or async execution.\n */\n\n\nfunction newGenerator(_ref) {\n  var name = _ref.name,\n      arity = _ref.arity,\n      _sync = _ref.sync,\n      _async = _ref.async,\n      errback = _ref.errback;\n  assertTypeof(\"string\", \"name\", name, true\n  /* allowUndefined */\n  );\n  assertTypeof(\"number\", \"arity\", arity, true\n  /* allowUndefined */\n  );\n  assertTypeof(\"function\", \"sync\", _sync);\n  assertTypeof(\"function\", \"async\", _async, true\n  /* allowUndefined */\n  );\n  assertTypeof(\"function\", \"errback\", errback, true\n  /* allowUndefined */\n  );\n\n  if (_async && errback) {\n    throw makeError(\"Expected one of either opts.async or opts.errback, but got _both_.\", GENSYNC_OPTIONS_ERROR);\n  }\n\n  if (typeof name !== \"string\") {\n    var fnName;\n\n    if (errback && errback.name && errback.name !== \"errback\") {\n      fnName = errback.name;\n    }\n\n    if (_async && _async.name && _async.name !== \"async\") {\n      fnName = _async.name.replace(/Async$/, \"\");\n    }\n\n    if (_sync && _sync.name && _sync.name !== \"sync\") {\n      fnName = _sync.name.replace(/Sync$/, \"\");\n    }\n\n    if (typeof fnName === \"string\") {\n      name = fnName;\n    }\n  }\n\n  if (typeof arity !== \"number\") {\n    arity = _sync.length;\n  }\n\n  return buildOperation({\n    name: name,\n    arity: arity,\n    sync: function sync(args) {\n      return _sync.apply(this, args);\n    },\n    async: function async(args, resolve, reject) {\n      if (_async) {\n        _async.apply(this, args).then(resolve, reject);\n      } else if (errback) {\n        errback.call.apply(errback, [this].concat(_toConsumableArray(args), [function (err, value) {\n          if (err == null) resolve(value);else reject(err);\n        }]));\n      } else {\n        resolve(_sync.apply(this, args));\n      }\n    }\n  });\n}\n\nfunction wrapGenerator(genFn) {\n  return setFunctionMetadata(genFn.name, genFn.length, function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return genFn.apply(this, args);\n  });\n}\n\nfunction buildOperation(_ref2) {\n  var name = _ref2.name,\n      arity = _ref2.arity,\n      sync = _ref2.sync,\n      async = _ref2.async;\n  return setFunctionMetadata(name, arity, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var resume,\n        _len5,\n        args,\n        _key5,\n        res,\n        result,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return GENSYNC_START;\n\n          case 2:\n            resume = _context.sent;\n\n            for (_len5 = _args.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n              args[_key5] = _args[_key5];\n            }\n\n            if (resume) {\n              _context.next = 7;\n              break;\n            }\n\n            // Break the tail call to avoid a bug in V8 v6.X with --harmony enabled.\n            res = sync.call(this, args);\n            return _context.abrupt(\"return\", res);\n\n          case 7:\n            try {\n              async.call(this, args, function (value) {\n                if (result) return;\n                result = {\n                  value: value\n                };\n                resume();\n              }, function (err) {\n                if (result) return;\n                result = {\n                  err: err\n                };\n                resume();\n              });\n            } catch (err) {\n              result = {\n                err: err\n              };\n              resume();\n            } // Suspend until the callbacks run. Will resume synchronously if the\n            // callback was already called.\n\n\n            _context.next = 10;\n            return GENSYNC_SUSPEND;\n\n          case 10:\n            if (!result.hasOwnProperty(\"err\")) {\n              _context.next = 12;\n              break;\n            }\n\n            throw result.err;\n\n          case 12:\n            return _context.abrupt(\"return\", result.value);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n}\n\nfunction evaluateSync(gen) {\n  var value;\n\n  while (!(_gen$next = gen.next(), value = _gen$next.value, _gen$next).done) {\n    var _gen$next;\n\n    assertStart(value, gen);\n  }\n\n  return value;\n}\n\nfunction evaluateAsync(gen, resolve, reject) {\n  (function step() {\n    try {\n      var value;\n\n      var _loop = function _loop() {\n        assertStart(value, gen); // If this throws, it is considered to have broken the contract\n        // established for async handlers. If these handlers are called\n        // synchronously, it is also considered bad behavior.\n\n        var sync = true;\n        var didSyncResume = false;\n        var out = gen.next(function () {\n          if (sync) {\n            didSyncResume = true;\n          } else {\n            step();\n          }\n        });\n        sync = false;\n        assertSuspend(out, gen);\n\n        if (!didSyncResume) {\n          // Callback wasn't called synchronously, so break out of the loop\n          // and let it call 'step' later.\n          return {\n            v: void 0\n          };\n        }\n      };\n\n      while (!(_gen$next2 = gen.next(), value = _gen$next2.value, _gen$next2).done) {\n        var _gen$next2;\n\n        var _ret = _loop();\n\n        if (typeof _ret === \"object\") return _ret.v;\n      }\n\n      return resolve(value);\n    } catch (err) {\n      return reject(err);\n    }\n  })();\n}\n\nfunction assertStart(value, gen) {\n  if (value === GENSYNC_START) return;\n  throwError(gen, makeError(\"Got unexpected yielded value in gensync generator: \".concat(JSON.stringify(value), \". Did you perhaps mean to use 'yield*' instead of 'yield'?\"), GENSYNC_EXPECTED_START));\n}\n\nfunction assertSuspend(_ref3, gen) {\n  var value = _ref3.value,\n      done = _ref3.done;\n  if (!done && value === GENSYNC_SUSPEND) return;\n  throwError(gen, makeError(done ? \"Unexpected generator completion. If you get this, it is probably a gensync bug.\" : \"Expected GENSYNC_SUSPEND, got \".concat(JSON.stringify(value), \". If you get this, it is probably a gensync bug.\"), GENSYNC_EXPECTED_SUSPEND));\n}\n\nfunction throwError(gen, err) {\n  // Call `.throw` so that users can step in a debugger to easily see which\n  // 'yield' passed an unexpected value. If the `.throw` call didn't throw\n  // back to the generator, we explicitly do it to stop the error\n  // from being swallowed by user code try/catches.\n  if (gen.throw) gen.throw(err);\n  throw err;\n}\n\nfunction isIterable(value) {\n  return !!value && (typeof value === \"object\" || typeof value === \"function\") && !value[Symbol.iterator];\n}\n\nfunction setFunctionMetadata(name, arity, fn) {\n  if (typeof name === \"string\") {\n    // This should always work on the supported Node versions, but for the\n    // sake of users that are compiling to older versions, we check for\n    // configurability so we don't throw.\n    var nameDesc = Object.getOwnPropertyDescriptor(fn, \"name\");\n\n    if (!nameDesc || nameDesc.configurable) {\n      Object.defineProperty(fn, \"name\", Object.assign(nameDesc || {}, {\n        configurable: true,\n        value: name\n      }));\n    }\n  }\n\n  if (typeof arity === \"number\") {\n    var lengthDesc = Object.getOwnPropertyDescriptor(fn, \"length\");\n\n    if (!lengthDesc || lengthDesc.configurable) {\n      Object.defineProperty(fn, \"length\", Object.assign(lengthDesc || {}, {\n        configurable: true,\n        value: arity\n      }));\n    }\n  }\n\n  return fn;\n}","map":{"version":3,"sources":["C:/Users/lenovo/letterBox/node_modules/gensync/index.js"],"names":["GENSYNC_START","Symbol","for","GENSYNC_SUSPEND","GENSYNC_EXPECTED_START","GENSYNC_EXPECTED_SUSPEND","GENSYNC_OPTIONS_ERROR","GENSYNC_RACE_NONEMPTY","GENSYNC_ERRBACK_NO_CALLBACK","module","exports","Object","assign","gensync","optsOrFn","genFn","newGenerator","wrapGenerator","makeFunctionAPI","all","buildOperation","name","arity","sync","args","items","Array","from","map","item","evaluateSync","async","resolve","reject","length","Promise","then","count","results","undefined","forEach","i","evaluateAsync","val","race","makeError","fns","apply","errback","cb","pop","gen","err","assertTypeof","type","value","allowUndefined","msg","code","Error","fnName","replace","call","setFunctionMetadata","resume","res","result","hasOwnProperty","next","done","assertStart","step","didSyncResume","out","assertSuspend","throwError","JSON","stringify","throw","isIterable","iterator","fn","nameDesc","getOwnPropertyDescriptor","configurable","defineProperty","lengthDesc"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// These use the global symbol registry so that multiple copies of this\n// library can work together in case they are not deduped.\nconst GENSYNC_START = Symbol.for(\"gensync:v1:start\");\nconst GENSYNC_SUSPEND = Symbol.for(\"gensync:v1:suspend\");\n\nconst GENSYNC_EXPECTED_START = \"GENSYNC_EXPECTED_START\";\nconst GENSYNC_EXPECTED_SUSPEND = \"GENSYNC_EXPECTED_SUSPEND\";\nconst GENSYNC_OPTIONS_ERROR = \"GENSYNC_OPTIONS_ERROR\";\nconst GENSYNC_RACE_NONEMPTY = \"GENSYNC_RACE_NONEMPTY\";\nconst GENSYNC_ERRBACK_NO_CALLBACK = \"GENSYNC_ERRBACK_NO_CALLBACK\";\n\nmodule.exports = Object.assign(\n  function gensync(optsOrFn) {\n    let genFn = optsOrFn;\n    if (typeof optsOrFn !== \"function\") {\n      genFn = newGenerator(optsOrFn);\n    } else {\n      genFn = wrapGenerator(optsOrFn);\n    }\n\n    return Object.assign(genFn, makeFunctionAPI(genFn));\n  },\n  {\n    all: buildOperation({\n      name: \"all\",\n      arity: 1,\n      sync: function(args) {\n        const items = Array.from(args[0]);\n        return items.map(item => evaluateSync(item));\n      },\n      async: function(args, resolve, reject) {\n        const items = Array.from(args[0]);\n\n        if (items.length === 0) {\n          Promise.resolve().then(() => resolve([]));\n          return;\n        }\n\n        let count = 0;\n        const results = items.map(() => undefined);\n        items.forEach((item, i) => {\n          evaluateAsync(\n            item,\n            val => {\n              results[i] = val;\n              count += 1;\n\n              if (count === results.length) resolve(results);\n            },\n            reject\n          );\n        });\n      },\n    }),\n    race: buildOperation({\n      name: \"race\",\n      arity: 1,\n      sync: function(args) {\n        const items = Array.from(args[0]);\n        if (items.length === 0) {\n          throw makeError(\"Must race at least 1 item\", GENSYNC_RACE_NONEMPTY);\n        }\n\n        return evaluateSync(items[0]);\n      },\n      async: function(args, resolve, reject) {\n        const items = Array.from(args[0]);\n        if (items.length === 0) {\n          throw makeError(\"Must race at least 1 item\", GENSYNC_RACE_NONEMPTY);\n        }\n\n        for (const item of items) {\n          evaluateAsync(item, resolve, reject);\n        }\n      },\n    }),\n  }\n);\n\n/**\n * Given a generator function, return the standard API object that executes\n * the generator and calls the callbacks.\n */\nfunction makeFunctionAPI(genFn) {\n  const fns = {\n    sync: function(...args) {\n      return evaluateSync(genFn.apply(this, args));\n    },\n    async: function(...args) {\n      return new Promise((resolve, reject) => {\n        evaluateAsync(genFn.apply(this, args), resolve, reject);\n      });\n    },\n    errback: function(...args) {\n      const cb = args.pop();\n      if (typeof cb !== \"function\") {\n        throw makeError(\n          \"Asynchronous function called without callback\",\n          GENSYNC_ERRBACK_NO_CALLBACK\n        );\n      }\n\n      let gen;\n      try {\n        gen = genFn.apply(this, args);\n      } catch (err) {\n        cb(err);\n        return;\n      }\n\n      evaluateAsync(gen, val => cb(undefined, val), err => cb(err));\n    },\n  };\n  return fns;\n}\n\nfunction assertTypeof(type, name, value, allowUndefined) {\n  if (\n    typeof value === type ||\n    (allowUndefined && typeof value === \"undefined\")\n  ) {\n    return;\n  }\n\n  let msg;\n  if (allowUndefined) {\n    msg = `Expected opts.${name} to be either a ${type}, or undefined.`;\n  } else {\n    msg = `Expected opts.${name} to be a ${type}.`;\n  }\n\n  throw makeError(msg, GENSYNC_OPTIONS_ERROR);\n}\nfunction makeError(msg, code) {\n  return Object.assign(new Error(msg), { code });\n}\n\n/**\n * Given an options object, return a new generator that dispatches the\n * correct handler based on sync or async execution.\n */\nfunction newGenerator({ name, arity, sync, async, errback }) {\n  assertTypeof(\"string\", \"name\", name, true /* allowUndefined */);\n  assertTypeof(\"number\", \"arity\", arity, true /* allowUndefined */);\n  assertTypeof(\"function\", \"sync\", sync);\n  assertTypeof(\"function\", \"async\", async, true /* allowUndefined */);\n  assertTypeof(\"function\", \"errback\", errback, true /* allowUndefined */);\n  if (async && errback) {\n    throw makeError(\n      \"Expected one of either opts.async or opts.errback, but got _both_.\",\n      GENSYNC_OPTIONS_ERROR\n    );\n  }\n\n  if (typeof name !== \"string\") {\n    let fnName;\n    if (errback && errback.name && errback.name !== \"errback\") {\n      fnName = errback.name;\n    }\n    if (async && async.name && async.name !== \"async\") {\n      fnName = async.name.replace(/Async$/, \"\");\n    }\n    if (sync && sync.name && sync.name !== \"sync\") {\n      fnName = sync.name.replace(/Sync$/, \"\");\n    }\n\n    if (typeof fnName === \"string\") {\n      name = fnName;\n    }\n  }\n\n  if (typeof arity !== \"number\") {\n    arity = sync.length;\n  }\n\n  return buildOperation({\n    name,\n    arity,\n    sync: function(args) {\n      return sync.apply(this, args);\n    },\n    async: function(args, resolve, reject) {\n      if (async) {\n        async.apply(this, args).then(resolve, reject);\n      } else if (errback) {\n        errback.call(this, ...args, (err, value) => {\n          if (err == null) resolve(value);\n          else reject(err);\n        });\n      } else {\n        resolve(sync.apply(this, args));\n      }\n    },\n  });\n}\n\nfunction wrapGenerator(genFn) {\n  return setFunctionMetadata(genFn.name, genFn.length, function(...args) {\n    return genFn.apply(this, args);\n  });\n}\n\nfunction buildOperation({ name, arity, sync, async }) {\n  return setFunctionMetadata(name, arity, function*(...args) {\n    const resume = yield GENSYNC_START;\n    if (!resume) {\n      // Break the tail call to avoid a bug in V8 v6.X with --harmony enabled.\n      const res = sync.call(this, args);\n      return res;\n    }\n\n    let result;\n    try {\n      async.call(\n        this,\n        args,\n        value => {\n          if (result) return;\n\n          result = { value };\n          resume();\n        },\n        err => {\n          if (result) return;\n\n          result = { err };\n          resume();\n        }\n      );\n    } catch (err) {\n      result = { err };\n      resume();\n    }\n\n    // Suspend until the callbacks run. Will resume synchronously if the\n    // callback was already called.\n    yield GENSYNC_SUSPEND;\n\n    if (result.hasOwnProperty(\"err\")) {\n      throw result.err;\n    }\n\n    return result.value;\n  });\n}\n\nfunction evaluateSync(gen) {\n  let value;\n  while (!({ value } = gen.next()).done) {\n    assertStart(value, gen);\n  }\n  return value;\n}\n\nfunction evaluateAsync(gen, resolve, reject) {\n  (function step() {\n    try {\n      let value;\n      while (!({ value } = gen.next()).done) {\n        assertStart(value, gen);\n\n        // If this throws, it is considered to have broken the contract\n        // established for async handlers. If these handlers are called\n        // synchronously, it is also considered bad behavior.\n        let sync = true;\n        let didSyncResume = false;\n        const out = gen.next(() => {\n          if (sync) {\n            didSyncResume = true;\n          } else {\n            step();\n          }\n        });\n        sync = false;\n\n        assertSuspend(out, gen);\n\n        if (!didSyncResume) {\n          // Callback wasn't called synchronously, so break out of the loop\n          // and let it call 'step' later.\n          return;\n        }\n      }\n\n      return resolve(value);\n    } catch (err) {\n      return reject(err);\n    }\n  })();\n}\n\nfunction assertStart(value, gen) {\n  if (value === GENSYNC_START) return;\n\n  throwError(\n    gen,\n    makeError(\n      `Got unexpected yielded value in gensync generator: ${JSON.stringify(\n        value\n      )}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,\n      GENSYNC_EXPECTED_START\n    )\n  );\n}\nfunction assertSuspend({ value, done }, gen) {\n  if (!done && value === GENSYNC_SUSPEND) return;\n\n  throwError(\n    gen,\n    makeError(\n      done\n        ? \"Unexpected generator completion. If you get this, it is probably a gensync bug.\"\n        : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(\n            value\n          )}. If you get this, it is probably a gensync bug.`,\n      GENSYNC_EXPECTED_SUSPEND\n    )\n  );\n}\n\nfunction throwError(gen, err) {\n  // Call `.throw` so that users can step in a debugger to easily see which\n  // 'yield' passed an unexpected value. If the `.throw` call didn't throw\n  // back to the generator, we explicitly do it to stop the error\n  // from being swallowed by user code try/catches.\n  if (gen.throw) gen.throw(err);\n  throw err;\n}\n\nfunction isIterable(value) {\n  return (\n    !!value &&\n    (typeof value === \"object\" || typeof value === \"function\") &&\n    !value[Symbol.iterator]\n  );\n}\n\nfunction setFunctionMetadata(name, arity, fn) {\n  if (typeof name === \"string\") {\n    // This should always work on the supported Node versions, but for the\n    // sake of users that are compiling to older versions, we check for\n    // configurability so we don't throw.\n    const nameDesc = Object.getOwnPropertyDescriptor(fn, \"name\");\n    if (!nameDesc || nameDesc.configurable) {\n      Object.defineProperty(\n        fn,\n        \"name\",\n        Object.assign(nameDesc || {}, {\n          configurable: true,\n          value: name,\n        })\n      );\n    }\n  }\n\n  if (typeof arity === \"number\") {\n    const lengthDesc = Object.getOwnPropertyDescriptor(fn, \"length\");\n    if (!lengthDesc || lengthDesc.configurable) {\n      Object.defineProperty(\n        fn,\n        \"length\",\n        Object.assign(lengthDesc || {}, {\n          configurable: true,\n          value: arity,\n        })\n      );\n    }\n  }\n\n  return fn;\n}\n"]},"metadata":{},"sourceType":"script"}