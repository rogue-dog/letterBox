{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\n\nvar t = require(\"@babel/types\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar PATTERN = /^[_$A-Z0-9]+$/;\n\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  var placeholderWhitelist = opts.placeholderWhitelist,\n      placeholderPattern = opts.placeholderPattern,\n      preserveComments = opts.preserveComments,\n      syntacticPlaceholders = opts.syntacticPlaceholders;\n  var ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  t.removePropertiesDeep(ast, {\n    preserveComments: preserveComments\n  });\n  formatter.validate(ast);\n  var syntactic = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  var legacy = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  var isLegacyRef = {\n    value: undefined\n  };\n  t.traverse(ast, placeholderVisitorHandler, {\n    syntactic: syntactic,\n    legacy: legacy,\n    isLegacyRef: isLegacyRef,\n    placeholderWhitelist: placeholderWhitelist,\n    placeholderPattern: placeholderPattern,\n    syntacticPlaceholders: syntacticPlaceholders\n  });\n  return Object.assign({\n    ast: ast\n  }, isLegacyRef.value ? legacy : syntactic);\n}\n\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n\n  var name;\n\n  if (t.isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (t.isIdentifier(node) || t.isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (t.isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n\n  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n\n  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n\n  ancestors = ancestors.slice();\n  var _ancestors = ancestors[ancestors.length - 1],\n      parent = _ancestors.node,\n      key = _ancestors.key;\n  var type;\n\n  if (t.isStringLiteral(node) || t.isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (t.isNewExpression(parent) && key === \"arguments\" || t.isCallExpression(parent) && key === \"arguments\" || t.isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (t.isExpressionStatement(parent) && !t.isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (t.isStatement(node) && t.isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  var _ref = state.isLegacyRef.value ? state.legacy : state.syntactic,\n      placeholders = _ref.placeholders,\n      placeholderNames = _ref.placeholderNames;\n\n  placeholders.push({\n    name: name,\n    type: type,\n    resolve: function resolve(ast) {\n      return resolveAncestors(ast, ancestors);\n    },\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast, ancestors) {\n  var parent = ast;\n\n  for (var i = 0; i < ancestors.length - 1; i++) {\n    var _ancestors$i = ancestors[i],\n        _key = _ancestors$i.key,\n        _index = _ancestors$i.index;\n\n    if (_index === undefined) {\n      parent = parent[_key];\n    } else {\n      parent = parent[_key][_index];\n    }\n  }\n\n  var _ancestors2 = ancestors[ancestors.length - 1],\n      key = _ancestors2.key,\n      index = _ancestors2.index;\n  return {\n    parent: parent,\n    key: key,\n    index: index\n  };\n}\n\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  var plugins = (parserOpts.plugins || []).slice();\n\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins: plugins\n  });\n\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    var loc = err.loc;\n\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}","map":{"version":3,"sources":["C:/Users/lenovo/letterBox/node_modules/@babel/template/lib/parse.js"],"names":["Object","defineProperty","exports","value","default","parseAndBuildMetadata","t","require","_parser","_codeFrame","PATTERN","formatter","code","opts","placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders","ast","parseWithCodeFrame","parser","removePropertiesDeep","validate","syntactic","placeholders","placeholderNames","Set","legacy","isLegacyRef","undefined","traverse","placeholderVisitorHandler","assign","node","ancestors","state","_state$placeholderWhi","name","isPlaceholder","Error","isIdentifier","isJSXIdentifier","isStringLiteral","test","has","slice","length","parent","key","type","expectedNode","isNewExpression","isCallExpression","isFunction","isExpressionStatement","isStatement","push","resolve","resolveAncestors","isDuplicate","add","i","index","parserOpts","plugins","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","parse","err","loc","message","codeFrameColumns","start"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\n\nvar t = require(\"@babel/types\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  t.removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const syntactic = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const legacy = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const isLegacyRef = {\n    value: undefined\n  };\n  t.traverse(ast, placeholderVisitorHandler, {\n    syntactic,\n    legacy,\n    isLegacyRef,\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  });\n  return Object.assign({\n    ast\n  }, isLegacyRef.value ? legacy : syntactic);\n}\n\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n\n  let name;\n\n  if (t.isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (t.isIdentifier(node) || t.isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (t.isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n\n  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n\n  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n\n  if (t.isStringLiteral(node) || t.isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (t.isNewExpression(parent) && key === \"arguments\" || t.isCallExpression(parent) && key === \"arguments\" || t.isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (t.isExpressionStatement(parent) && !t.isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (t.isStatement(node) && t.isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const {\n    placeholders,\n    placeholderNames\n  } = state.isLegacyRef.value ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\n\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  const plugins = (parserOpts.plugins || []).slice();\n\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins\n  });\n\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}"]},"metadata":{},"sourceType":"script"}