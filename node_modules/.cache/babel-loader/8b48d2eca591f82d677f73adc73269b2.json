{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/lenovo/letterBox/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:/Users/lenovo/letterBox/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/lenovo/letterBox/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/lenovo/letterBox/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"C:/Users/lenovo/letterBox/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(genTrue),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(getCachedValue),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(getCachedValueOrWait);\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.assertSimpleType = assertSimpleType;\n\nfunction _gensync() {\n  var data = _interopRequireDefault(require(\"gensync\"));\n\n  _gensync = function _gensync() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar synchronize = function synchronize(gen) {\n  return (0, _gensync().default)(gen).sync;\n};\n\nfunction genTrue(data) {\n  return _regeneratorRuntime.wrap(function genTrue$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", true);\n\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\n\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\n\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\n\nfunction makeCachedFunction(CallCache, handler) {\n  var callCacheSync = new CallCache();\n  var callCacheAsync = new CallCache();\n  var futureCache = new CallCache();\n  return /*#__PURE__*/_regeneratorRuntime.mark(function cachedFunction(arg, data) {\n    var asyncContext, callCache, cached, cache, handlerResult, finishLock, value, gen;\n    return _regeneratorRuntime.wrap(function cachedFunction$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.delegateYield((0, _async.isAsync)(), \"t0\", 1);\n\n          case 1:\n            asyncContext = _context2.t0;\n            callCache = asyncContext ? callCacheAsync : callCacheSync;\n            return _context2.delegateYield(getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data), \"t1\", 4);\n\n          case 4:\n            cached = _context2.t1;\n\n            if (!cached.valid) {\n              _context2.next = 7;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", cached.value);\n\n          case 7:\n            cache = new CacheConfigurator(data);\n            handlerResult = handler(arg, cache);\n\n            if (!(0, _util.isIterableIterator)(handlerResult)) {\n              _context2.next = 15;\n              break;\n            }\n\n            gen = handlerResult;\n            return _context2.delegateYield((0, _async.onFirstPause)(gen, function () {\n              finishLock = setupAsyncLocks(cache, futureCache, arg);\n            }), \"t2\", 12);\n\n          case 12:\n            value = _context2.t2;\n            _context2.next = 16;\n            break;\n\n          case 15:\n            value = handlerResult;\n\n          case 16:\n            updateFunctionCache(callCache, cache, arg, value);\n\n            if (finishLock) {\n              futureCache.delete(arg);\n              finishLock.release(value);\n            }\n\n            return _context2.abrupt(\"return\", value);\n\n          case 19:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, cachedFunction);\n  });\n}\n\nfunction getCachedValue(cache, arg, data) {\n  var cachedValue, _iterator, _step, _step$value, value, valid;\n\n  return _regeneratorRuntime.wrap(function getCachedValue$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          cachedValue = cache.get(arg);\n\n          if (!cachedValue) {\n            _context3.next = 20;\n            break;\n          }\n\n          _iterator = _createForOfIteratorHelper(cachedValue);\n          _context3.prev = 3;\n\n          _iterator.s();\n\n        case 5:\n          if ((_step = _iterator.n()).done) {\n            _context3.next = 12;\n            break;\n          }\n\n          _step$value = _step.value, value = _step$value.value, valid = _step$value.valid;\n          return _context3.delegateYield(valid(data), \"t0\", 8);\n\n        case 8:\n          if (!_context3.t0) {\n            _context3.next = 10;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            valid: true,\n            value: value\n          });\n\n        case 10:\n          _context3.next = 5;\n          break;\n\n        case 12:\n          _context3.next = 17;\n          break;\n\n        case 14:\n          _context3.prev = 14;\n          _context3.t1 = _context3[\"catch\"](3);\n\n          _iterator.e(_context3.t1);\n\n        case 17:\n          _context3.prev = 17;\n\n          _iterator.f();\n\n          return _context3.finish(17);\n\n        case 20:\n          return _context3.abrupt(\"return\", {\n            valid: false,\n            value: null\n          });\n\n        case 21:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked2, null, [[3, 14, 17, 20]]);\n}\n\nfunction getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  var cached, _cached, value;\n\n  return _regeneratorRuntime.wrap(function getCachedValueOrWait$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.delegateYield(getCachedValue(callCache, arg, data), \"t0\", 1);\n\n        case 1:\n          cached = _context4.t0;\n\n          if (!cached.valid) {\n            _context4.next = 4;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", cached);\n\n        case 4:\n          if (!asyncContext) {\n            _context4.next = 11;\n            break;\n          }\n\n          return _context4.delegateYield(getCachedValue(futureCache, arg, data), \"t1\", 6);\n\n        case 6:\n          _cached = _context4.t1;\n\n          if (!_cached.valid) {\n            _context4.next = 11;\n            break;\n          }\n\n          return _context4.delegateYield((0, _async.waitFor)(_cached.value.promise), \"t2\", 9);\n\n        case 9:\n          value = _context4.t2;\n          return _context4.abrupt(\"return\", {\n            valid: true,\n            value: value\n          });\n\n        case 11:\n          return _context4.abrupt(\"return\", {\n            valid: false,\n            value: null\n          });\n\n        case 12:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked3);\n}\n\nfunction setupAsyncLocks(config, futureCache, arg) {\n  var finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\n\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  var cachedValue = cache.get(arg);\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value: value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"invalidate\":\n      cachedValue = [{\n        value: value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value: value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value: value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n\n  }\n}\n\nvar CacheConfigurator = /*#__PURE__*/function () {\n  function CacheConfigurator(data) {\n    _classCallCheck(this, CacheConfigurator);\n\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n\n  _createClass(CacheConfigurator, [{\n    key: \"simple\",\n    value: function simple() {\n      return makeSimpleConfigurator(this);\n    }\n  }, {\n    key: \"mode\",\n    value: function mode() {\n      if (this._never) return \"never\";\n      if (this._forever) return \"forever\";\n      if (this._invalidate) return \"invalidate\";\n      return \"valid\";\n    }\n  }, {\n    key: \"forever\",\n    value: function forever() {\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._never) {\n        throw new Error(\"Caching has already been configured with .never()\");\n      }\n\n      this._forever = true;\n      this._configured = true;\n    }\n  }, {\n    key: \"never\",\n    value: function never() {\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._forever) {\n        throw new Error(\"Caching has already been configured with .forever()\");\n      }\n\n      this._never = true;\n      this._configured = true;\n    }\n  }, {\n    key: \"using\",\n    value: function using(handler) {\n      var _this = this;\n\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._never || this._forever) {\n        throw new Error(\"Caching has already been configured with .never or .forever()\");\n      }\n\n      this._configured = true;\n      var key = handler(this._data);\n      var fn = (0, _async.maybeAsync)(handler, \"You appear to be using an async cache handler, but Babel has been called synchronously\");\n\n      if ((0, _async.isThenable)(key)) {\n        return key.then(function (key) {\n          _this._pairs.push([key, fn]);\n\n          return key;\n        });\n      }\n\n      this._pairs.push([key, fn]);\n\n      return key;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(handler) {\n      this._invalidate = true;\n      return this.using(handler);\n    }\n  }, {\n    key: \"validator\",\n    value: function validator() {\n      var pairs = this._pairs;\n      return /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n        var _iterator2, _step2, _step2$value, key, fn;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _iterator2 = _createForOfIteratorHelper(pairs);\n                _context5.prev = 1;\n\n                _iterator2.s();\n\n              case 3:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], fn = _step2$value[1];\n                _context5.t0 = key;\n                return _context5.delegateYield(fn(data), \"t1\", 7);\n\n              case 7:\n                _context5.t2 = _context5.t1;\n\n                if (!(_context5.t0 !== _context5.t2)) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", false);\n\n              case 10:\n                _context5.next = 3;\n                break;\n\n              case 12:\n                _context5.next = 17;\n                break;\n\n              case 14:\n                _context5.prev = 14;\n                _context5.t3 = _context5[\"catch\"](1);\n\n                _iterator2.e(_context5.t3);\n\n              case 17:\n                _context5.prev = 17;\n\n                _iterator2.f();\n\n                return _context5.finish(17);\n\n              case 20:\n                return _context5.abrupt(\"return\", true);\n\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee, null, [[1, 14, 17, 20]]);\n      });\n    }\n  }, {\n    key: \"deactivate\",\n    value: function deactivate() {\n      this._active = false;\n    }\n  }, {\n    key: \"configured\",\n    value: function configured() {\n      return this._configured;\n    }\n  }]);\n\n  return CacheConfigurator;\n}();\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(function () {\n      return assertSimpleType(val());\n    });\n  }\n\n  cacheFn.forever = function () {\n    return cache.forever();\n  };\n\n  cacheFn.never = function () {\n    return cache.never();\n  };\n\n  cacheFn.using = function (cb) {\n    return cache.using(function () {\n      return assertSimpleType(cb());\n    });\n  };\n\n  cacheFn.invalidate = function (cb) {\n    return cache.invalidate(function () {\n      return assertSimpleType(cb());\n    });\n  };\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(\"You appear to be using an async cache handler, \" + \"which your current version of Babel does not support. \" + \"We may add support for this in the future, \" + \"but if you're on the most recent version of @babel/core and still \" + \"seeing this error, then you'll need to synchronously handle your caching logic.\");\n  }\n\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}\n\nvar Lock = /*#__PURE__*/function () {\n  function Lock() {\n    var _this2 = this;\n\n    _classCallCheck(this, Lock);\n\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(function (resolve) {\n      _this2._resolve = resolve;\n    });\n  }\n\n  _createClass(Lock, [{\n    key: \"release\",\n    value: function release(value) {\n      this.released = true;\n\n      this._resolve(value);\n    }\n  }]);\n\n  return Lock;\n}();","map":{"version":3,"sources":["C:/Users/lenovo/letterBox/node_modules/@babel/core/lib/config/caching.js"],"names":["genTrue","getCachedValue","getCachedValueOrWait","Object","defineProperty","exports","value","makeWeakCache","makeWeakCacheSync","makeStrongCache","makeStrongCacheSync","assertSimpleType","_gensync","data","_interopRequireDefault","require","_async","_util","obj","__esModule","default","synchronize","gen","sync","handler","makeCachedFunction","WeakMap","Map","CallCache","callCacheSync","callCacheAsync","futureCache","cachedFunction","arg","isAsync","asyncContext","callCache","cached","valid","cache","CacheConfigurator","handlerResult","isIterableIterator","onFirstPause","finishLock","setupAsyncLocks","updateFunctionCache","delete","release","cachedValue","get","waitFor","promise","config","Lock","configured","forever","deactivate","mode","set","validator","push","_active","_never","_forever","_invalidate","_configured","_pairs","_data","makeSimpleConfigurator","Error","key","fn","maybeAsync","isThenable","then","using","pairs","cacheFn","val","never","cb","invalidate","released","_resolve","Promise","resolve"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.assertSimpleType = assertSimpleType;\n\nfunction _gensync() {\n  const data = _interopRequireDefault(require(\"gensync\"));\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst synchronize = gen => {\n  return (0, _gensync().default)(gen).sync;\n};\n\nfunction* genTrue(data) {\n  return true;\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\n\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\n\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\n\nfunction makeCachedFunction(CallCache, handler) {\n  const callCacheSync = new CallCache();\n  const callCacheAsync = new CallCache();\n  const futureCache = new CallCache();\n  return function* cachedFunction(arg, data) {\n    const asyncContext = yield* (0, _async.isAsync)();\n    const callCache = asyncContext ? callCacheAsync : callCacheSync;\n    const cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);\n    if (cached.valid) return cached.value;\n    const cache = new CacheConfigurator(data);\n    const handlerResult = handler(arg, cache);\n    let finishLock;\n    let value;\n\n    if ((0, _util.isIterableIterator)(handlerResult)) {\n      const gen = handlerResult;\n      value = yield* (0, _async.onFirstPause)(gen, () => {\n        finishLock = setupAsyncLocks(cache, futureCache, arg);\n      });\n    } else {\n      value = handlerResult;\n    }\n\n    updateFunctionCache(callCache, cache, arg, value);\n\n    if (finishLock) {\n      futureCache.delete(arg);\n      finishLock.release(value);\n    }\n\n    return value;\n  };\n}\n\nfunction* getCachedValue(cache, arg, data) {\n  const cachedValue = cache.get(arg);\n\n  if (cachedValue) {\n    for (const {\n      value,\n      valid\n    } of cachedValue) {\n      if (yield* valid(data)) return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  const cached = yield* getCachedValue(callCache, arg, data);\n\n  if (cached.valid) {\n    return cached;\n  }\n\n  if (asyncContext) {\n    const cached = yield* getCachedValue(futureCache, arg, data);\n\n    if (cached.valid) {\n      const value = yield* (0, _async.waitFor)(cached.value.promise);\n      return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction setupAsyncLocks(config, futureCache, arg) {\n  const finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\n\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  let cachedValue = cache.get(arg);\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"invalidate\":\n      cachedValue = [{\n        value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n\n  }\n}\n\nclass CacheConfigurator {\n  constructor(data) {\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n\n    this._never = true;\n    this._configured = true;\n  }\n\n  using(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._configured = true;\n    const key = handler(this._data);\n    const fn = (0, _async.maybeAsync)(handler, `You appear to be using an async cache handler, but Babel has been called synchronously`);\n\n    if ((0, _async.isThenable)(key)) {\n      return key.then(key => {\n        this._pairs.push([key, fn]);\n\n        return key;\n      });\n    }\n\n    this._pairs.push([key, fn]);\n\n    return key;\n  }\n\n  invalidate(handler) {\n    this._invalidate = true;\n    return this.using(handler);\n  }\n\n  validator() {\n    const pairs = this._pairs;\n    return function* (data) {\n      for (const [key, fn] of pairs) {\n        if (key !== (yield* fn(data))) return false;\n      }\n\n      return true;\n    };\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n\n}\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n\n  cacheFn.forever = () => cache.forever();\n\n  cacheFn.never = () => cache.never();\n\n  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));\n\n  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(`You appear to be using an async cache handler, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously handle your caching logic.`);\n  }\n\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}\n\nclass Lock {\n  constructor() {\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  release(value) {\n    this.released = true;\n\n    this._resolve(value);\n  }\n\n}"]},"metadata":{},"sourceType":"script"}